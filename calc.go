// Package calc can evaluate mathematical expressions that are in string form.
package calc

import (
	"encoding/json"
	"fmt"
	"math"
)

var debug = false

func SetDebug(b bool) {
	debug = b
}

func Eval(input string) (float64, error) {
	// run lexer
	tokens, err := tokenize(input)
	if err != nil {
		return math.NaN(), err
	}
	if debug {
		fmt.Println("the following instructions have been read by the lexer:")
		for _, t := range tokens {
			printToken(t)
		}
	}

	// run parser
	if debug {
		fmt.Printf("the following abstract syntax tree has been generated by the parser.\n" +
			"operator conversion:\n")
		fmt.Printf("%v -> %v\n", '+', "+")
		fmt.Printf("%v -> %v\n", '-', "-")
		fmt.Printf("%v -> %v\n", '*', "*")
		fmt.Printf("%v -> %v\n", '/', "/")
		fmt.Printf("%v -> %v\n", ',', ",")
		fmt.Printf("%v -> %v\n", '(', "(")
		fmt.Printf("%v -> %v\n", ')', ")")
		fmt.Printf("%v -> %v\n", '{', "{")
		fmt.Printf("%v -> %v\n", '}', "}")
	}
	var o Operation
	o, err = parse(tokens)
	if err != nil {
		return math.NaN(), err
	}
	if debug {
		b, _ := json.MarshalIndent(getAST(o), "", "  ")
		fmt.Println(string(b))
	}

	// evaluate result
	if o == nil {
		return 0, nil
	}
	var res float64
	res, err = o.Eval()
	if err != nil {
		return math.NaN(), err
	}
	return res, nil
}

func printToken(t Token) {
	switch t.Type() {
	case typeOperator:
		fallthrough
	case typeComma:
		fallthrough
	case typeBraces:
		fallthrough
	case typeParentheses:
		fmt.Printf("\t%s\t%s\n", t.Type(), string(t.Value().(rune)))
	case typeLiteral:
		fmt.Printf("\t%s\t%g\n", t.Type(), t.Value().(float64))
	case typeIdentifier:
		fmt.Printf("\t%s\t%s\n", t.Type(), t.Value().(string))
	}
}

func getAST(in Operation) (res map[string]interface{}) {
	if in == nil {
		return map[string]interface{}{
			"value": 0,
		}
	}
	res = map[string]interface{}{}
	if in.Operator() == 'm' {
		m := in.(*macroOperation).m
		if sqrt, ok := m.(*Sqrt); ok {
			res["_identifier"] = "sqrt"
			res["value"] = getAST(sqrt.value)
		} else if pow, ok := m.(*Pow); ok {
			res["_identifier"] = "pow"
			res["base"] = getAST(pow.base)
			res["exp"] = getAST(pow.exp)
		} else {
			res["error"] = fmt.Sprintf("unknown macro: %+v\n", m)
		}
	} else if in.Operator() == 'l' {
		l := in.(*literalOperation)
		res["value"] = l.value
	} else {
		res["_operand"] = string(in.Operator())
		res["left"] = getAST(in.Left())
		res["right"] = getAST(in.Right())
	}
	return
}
