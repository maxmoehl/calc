// Package calc can evaluate mathematical expressions that are in string form.
package calc

import (
	"encoding/json"
	"fmt"
	"math"

	"github.com/maxmoehl/calc/types"
)

var debug = false

func SetDebug(b bool) {
	debug = b
}

// Eval is the main entry point for the calc package. It takes a single string
// as input and runs the lexer and parser to create a abstract syntax tree that
// can be evaluated to get the final result. If any errors occur math.Nan and
// the error are returned.
func Eval(input string) (float64, error) {
	// run lexer
	tokens, err := tokenize(input)
	if err != nil {
		return math.NaN(), err
	}
	if debug {
		fmt.Println("the following instructions have been read by the lexer:")
		for _, t := range tokens {
			printToken(t)
		}
	}

	// run parser
	if debug {
		fmt.Printf("the following abstract syntax tree has been generated by the parser.\n" +
			"operator conversion:\n")
		fmt.Printf("%v -> %v\n", '+', "+")
		fmt.Printf("%v -> %v\n", '-', "-")
		fmt.Printf("%v -> %v\n", '*', "*")
		fmt.Printf("%v -> %v\n", '/', "/")
		fmt.Printf("%v -> %v\n", ',', ",")
		fmt.Printf("%v -> %v\n", '(', "(")
		fmt.Printf("%v -> %v\n", ')', ")")
		fmt.Printf("%v -> %v\n", '{', "{")
		fmt.Printf("%v -> %v\n", '}', "}")
	}
	var o types.Node
	o, err = parse(tokens)
	if err != nil {
		return math.NaN(), err
	}
	if debug {
		b, _ := json.MarshalIndent(getAST(o), "", "  ")
		fmt.Println(string(b))
	}

	// evaluate result
	if o == nil {
		return 0, nil
	}
	var res float64
	res, err = o.Eval()
	if err != nil {
		return math.NaN(), err
	}
	return res, nil
}

// printToken prints a single token in its correct string representation.
func printToken(t Token) {
	switch t.Type() {
	case typeOperator:
		fallthrough
	case typeComma:
		fallthrough
	case typeBrace:
		fallthrough
	case typeParenthesis:
		fmt.Printf("\t%s\t%s\n", getTypeStandardLength(t.Type()), string(t.Value().(rune)))
	case typeLiteral:
		fmt.Printf("\t%s\t%g\n", getTypeStandardLength(t.Type()), t.Value().(float64))
	case typeIdentifier:
		fmt.Printf("\t%s\t%s\n", getTypeStandardLength(t.Type()), t.Value().(string))
	}
}

// getTypeStandardLength takes a type and appends as many spaces to it to get
// the same length as the longest type. Currently the length is 11.
func getTypeStandardLength(t string) string {
	for len(t) < 11 {
		t += " "
	}
	return t
}

// getAST is a function that tries to uncover as much information as possible
// from the abstract syntax tree and stores it in a map. That map can then be
// printed to give a detailed overview on what the current operation looks like
// in memory.
func getAST(in types.Node) (res map[string]interface{}) {
	if in == nil {
		return map[string]interface{}{
			"value": "nil (=0)",
		}
	}
	res = map[string]interface{}{}
	if m, ok := in.(*macro); ok {
		res["macro"] = map[string]string{
			"_type": fmt.Sprintf("%T", m.m),
			"representation": fmt.Sprintf("%+v", m.m),
		}
	} else if l, ok := in.(*literal); ok {
		res["value"] = l.value
	} else if o, ok := in.(*operation); ok {
		res["_operand"] = string(o.operator)
		res["left"] = getAST(o.left)
		res["right"] = getAST(o.right)
	}
	return
}
